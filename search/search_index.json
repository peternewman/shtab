{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What: Automatically generate shell tab completion scripts for Python CLI apps Why: Speed & correctness. Alternatives like argcomplete and pyzshcomplete are slow and have side-effects How: shtab processes an argparse.ArgumentParser object to generate a tab completion script for your shell Features # Outputs tab completion scripts for bash zsh tcsh Supports argparse docopt (via argopt ) Supports arguments, options and subparsers Supports choices (e.g. --say={hello,goodbye} ) Supports file and directory path completion Supports custom path completion (e.g. --file={*.txt} ) Installation # pip conda pip install shtab conda install -c conda-forge shtab bash users who have never used any kind of tab completion before should also follow the OS-specific instructions below. Ubuntu/Debian MacOS Recent versions should have completion already enabled. For older versions, first run sudo apt install --reinstall bash-completion , then make sure these lines appear in ~/.bashrc : # enable bash completion in interactive shells if ! shopt -oq posix ; then if [ -f /usr/share/bash-completion/bash_completion ] ; then . /usr/share/bash-completion/bash_completion elif [ -f /etc/bash_completion ] ; then . /etc/bash_completion fi fi First run brew install bash-completion , then add the following to ~/.bash_profile : if [ -f $( brew --prefix ) /etc/bash_completion ] ; then . $( brew --prefix ) /etc/bash_completion fi FAQs # Not working? Make sure that shtab and the application you're trying to complete are both accessible from your environment. Make sure that prog is set: if using options.entry_points.console_scripts=MY_PROG=... , then ensure the main parser's prog matches argparse.ArgumentParser(prog=\"MY_PROG\") or override it using shtab MY_PROG.get_main_parser --prog=MY_PROG . if executing a script file ./MY_PROG.py (with a shebang #!/usr/bin/env python ) directly, then use argparse.ArgumentParser(prog=\"MY_PROG.py\") or override it using shtab MY_PROG.get_main_parser --prog=MY_PROG.py . Make sure that all arguments have help messages ( parser.add_argument('positional', help=\"documented; i.e. not hidden\") ). Ask a general question on StackOverflow . Report bugs and open feature requests on GitHub . \"Eager\" installation (completions are re-generated upon login/terminal start) is recommended. Naturally, shtab and the CLI application to complete should be accessible/importable from the login environment. If installing shtab in a different virtual environment, you'd have to add a line somewhere appropriate (e.g. $CONDA_PREFIX/etc/conda/activate.d/env_vars.sh ). By default, shtab will silently do nothing if it cannot import the requested application. Use -u, --error-unimportable to noisily complain. Alternatives # argcomplete executes the underlying script every time <TAB> is pressed (slow and has side-effects) only provides bash completion pyzshcomplete executes the underlying script every time <TAB> is pressed (slow and has side-effects) only provides zsh completion click different framework completely replacing the builtin argparse solves multiple problems (rather than POSIX-style \"do one thing well\") Contributions # Please do open issues & pull requests ! Some ideas: support fish support powershell See CONTRIBUTING.md for more guidance.","title":"Home"},{"location":"#features","text":"Outputs tab completion scripts for bash zsh tcsh Supports argparse docopt (via argopt ) Supports arguments, options and subparsers Supports choices (e.g. --say={hello,goodbye} ) Supports file and directory path completion Supports custom path completion (e.g. --file={*.txt} )","title":"Features"},{"location":"#installation","text":"pip conda pip install shtab conda install -c conda-forge shtab bash users who have never used any kind of tab completion before should also follow the OS-specific instructions below. Ubuntu/Debian MacOS Recent versions should have completion already enabled. For older versions, first run sudo apt install --reinstall bash-completion , then make sure these lines appear in ~/.bashrc : # enable bash completion in interactive shells if ! shopt -oq posix ; then if [ -f /usr/share/bash-completion/bash_completion ] ; then . /usr/share/bash-completion/bash_completion elif [ -f /etc/bash_completion ] ; then . /etc/bash_completion fi fi First run brew install bash-completion , then add the following to ~/.bash_profile : if [ -f $( brew --prefix ) /etc/bash_completion ] ; then . $( brew --prefix ) /etc/bash_completion fi","title":"Installation"},{"location":"#faqs","text":"Not working? Make sure that shtab and the application you're trying to complete are both accessible from your environment. Make sure that prog is set: if using options.entry_points.console_scripts=MY_PROG=... , then ensure the main parser's prog matches argparse.ArgumentParser(prog=\"MY_PROG\") or override it using shtab MY_PROG.get_main_parser --prog=MY_PROG . if executing a script file ./MY_PROG.py (with a shebang #!/usr/bin/env python ) directly, then use argparse.ArgumentParser(prog=\"MY_PROG.py\") or override it using shtab MY_PROG.get_main_parser --prog=MY_PROG.py . Make sure that all arguments have help messages ( parser.add_argument('positional', help=\"documented; i.e. not hidden\") ). Ask a general question on StackOverflow . Report bugs and open feature requests on GitHub . \"Eager\" installation (completions are re-generated upon login/terminal start) is recommended. Naturally, shtab and the CLI application to complete should be accessible/importable from the login environment. If installing shtab in a different virtual environment, you'd have to add a line somewhere appropriate (e.g. $CONDA_PREFIX/etc/conda/activate.d/env_vars.sh ). By default, shtab will silently do nothing if it cannot import the requested application. Use -u, --error-unimportable to noisily complain.","title":"FAQs"},{"location":"#alternatives","text":"argcomplete executes the underlying script every time <TAB> is pressed (slow and has side-effects) only provides bash completion pyzshcomplete executes the underlying script every time <TAB> is pressed (slow and has side-effects) only provides zsh completion click different framework completely replacing the builtin argparse solves multiple problems (rather than POSIX-style \"do one thing well\")","title":"Alternatives"},{"location":"#contributions","text":"Please do open issues & pull requests ! Some ideas: support fish support powershell See CONTRIBUTING.md for more guidance.","title":"Contributions"},{"location":"contributing/","text":"Contributing # Tests # When contributing pull requests, it's a good idea to run basic checks locally: # install development dependencies shtab ( master ) $ pip install pre-commit -r requirements-dev.txt shtab ( master ) $ pre-commit install # install pre-commit checks shtab ( master ) $ pytest # run all tests Layout # Most of the magic lives in shtab/__init__.py . shtab/ __init__.py complete() - primary API, calls shell-specific versions complete_bash() complete_zsh() complete_tcsh() ... add_argument_to() - convenience function for library integration Optional() , Required() , Choice() - legacy helpers for advanced completion (e.g. dirs, files, *.txt ) main.py get_main_parser() - returns shtab 's own parser object main() - shtab 's own CLI application Given that the number of completions a program may need would likely be less than a million, the focus is on readability rather than premature speed optimisations. The generated code itself, on the other had, should be fast. Helper functions such as replace_format allows use of curly braces {} in string snippets without clashing between Python's str.format and shell parameter expansion. The generated shell code itself is also meant to be readable. Releases # Tests and deployment are handled automatically by continuous integration. Simply tag a commit v{major}.{minor}.{patch} and wait for a draft release to appear at https://github.com/iterative/shtab/releases . Tidy up the draft's description before publishing it. Note that tagging a release is possible by commenting /tag vM.m.p HASH in an issue or PR.","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#tests","text":"When contributing pull requests, it's a good idea to run basic checks locally: # install development dependencies shtab ( master ) $ pip install pre-commit -r requirements-dev.txt shtab ( master ) $ pre-commit install # install pre-commit checks shtab ( master ) $ pytest # run all tests","title":"Tests"},{"location":"contributing/#layout","text":"Most of the magic lives in shtab/__init__.py . shtab/ __init__.py complete() - primary API, calls shell-specific versions complete_bash() complete_zsh() complete_tcsh() ... add_argument_to() - convenience function for library integration Optional() , Required() , Choice() - legacy helpers for advanced completion (e.g. dirs, files, *.txt ) main.py get_main_parser() - returns shtab 's own parser object main() - shtab 's own CLI application Given that the number of completions a program may need would likely be less than a million, the focus is on readability rather than premature speed optimisations. The generated code itself, on the other had, should be fast. Helper functions such as replace_format allows use of curly braces {} in string snippets without clashing between Python's str.format and shell parameter expansion. The generated shell code itself is also meant to be readable.","title":"Layout"},{"location":"contributing/#releases","text":"Tests and deployment are handled automatically by continuous integration. Simply tag a commit v{major}.{minor}.{patch} and wait for a draft release to appear at https://github.com/iterative/shtab/releases . Tidy up the draft's description before publishing it. Note that tagging a release is possible by commenting /tag vM.m.p HASH in an issue or PR.","title":"Releases"},{"location":"licence/","text":"Copyright 2020-2021 Casper da Costa-Luis Licensed under the Apache Licence, Version 2.0 (the \"Licence\"); you may not use this project except in compliance with the Licence. You may obtain a copy of the Licence at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the Licence is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the Licence for the specific language governing permissions and limitations under the Licence.","title":"Licence"},{"location":"ref/","text":"shtab # complete # def complete ( parser : ArgumentParser , shell : str = \"bash\" , root_prefix : Opt [ str ] = None , preamble : Union [ str , Dict ] = \"\" , choice_functions : Opt [ Any ] = None ) -> str parser : argparse.ArgumentParser shell : str (bash/zsh) root_prefix : str or None prefix for shell functions to avoid clashes (default: \"_{parser.prog}\") preamble : dict or str mapping shell to text to prepend to generated script (e.g. {\"bash\": \"_myprog_custom_function(){ echo hello }\"} ) choice_functions : deprecated N.B. parser.add_argument().complete = ... can be used to define custom completions (e.g. filenames). See <../examples/pathcomplete.py>. add_argument_to # def add_argument_to ( parser , option_string = \"--print-completion\" , help = \"print shell completion script\" , parent = None , preamble = \"\" ) parser : argparse.ArgumentParser option_string : str or list[str] iff positional (no - prefix) then parser is assumed to actually be a subparser (subcommand mode) help : str parent : argparse.ArgumentParser required in subcommand mode","title":"Reference"},{"location":"ref/#shtab","text":"","title":"shtab"},{"location":"ref/#complete","text":"def complete ( parser : ArgumentParser , shell : str = \"bash\" , root_prefix : Opt [ str ] = None , preamble : Union [ str , Dict ] = \"\" , choice_functions : Opt [ Any ] = None ) -> str parser : argparse.ArgumentParser shell : str (bash/zsh) root_prefix : str or None prefix for shell functions to avoid clashes (default: \"_{parser.prog}\") preamble : dict or str mapping shell to text to prepend to generated script (e.g. {\"bash\": \"_myprog_custom_function(){ echo hello }\"} ) choice_functions : deprecated N.B. parser.add_argument().complete = ... can be used to define custom completions (e.g. filenames). See <../examples/pathcomplete.py>.","title":"complete"},{"location":"ref/#add_argument_to","text":"def add_argument_to ( parser , option_string = \"--print-completion\" , help = \"print shell completion script\" , parent = None , preamble = \"\" ) parser : argparse.ArgumentParser option_string : str or list[str] iff positional (no - prefix) then parser is assumed to actually be a subparser (subcommand mode) help : str parent : argparse.ArgumentParser required in subcommand mode","title":"add_argument_to"},{"location":"use/","text":"Usage # There are two ways of using shtab : CLI Usage : shtab 's own CLI interface for external applications may not require any code modifications whatsoever end-users execute shtab your_cli_app.your_parser_object Library Usage : as a library integrated into your CLI application adds a couple of lines to your application argument mode: end-users execute your_cli_app --print-completion {bash,zsh,tcsh} subparser mode: end-users execute your_cli_app completion {bash,zsh,tcsh} CLI Usage # The only requirement is that external CLI applications provide an importable argparse.ArgumentParser object (or alternatively an importable function which returns a parser object). This may require a trivial code change. Once that's done, simply put the output of shtab --shell=your_shell your_cli_app.your_parser_object somewhere your shell looks for completions. Below are various examples of enabling shtab 's own tab completion scripts. Info If both shtab and the module it's completing are globally importable, eager usage is an option. \"Eager\" means automatically updating completions each time a terminal is opened. bash Eager bash zsh Eager zsh tcsh Eager tcsh shtab --shell = bash shtab.main.get_main_parser --error-unimportable \\ | sudo tee \" $BASH_COMPLETION_COMPAT_DIR \" /shtab There are a few options: # Install locally echo 'eval \"$(shtab --shell=bash shtab.main.get_main_parser)\"' \\ >> ~/.bash_completion # Install locally (lazy load for bash-completion>=2.8) echo 'eval \"$(shtab --shell=bash shtab.main.get_main_parser)\"' \\ > \" ${ BASH_COMPLETION_USER_DIR :- ${ XDG_DATA_HOME :- $HOME /.local/share } /bash-completion } /completions/shtab\" # Install system-wide echo 'eval \"$(shtab --shell=bash shtab.main.get_main_parser)\"' \\ | sudo tee \" $( pkg-config --variable = completionsdir bash-completion ) \" /shtab # Install system-wide (legacy) echo 'eval \"$(shtab --shell=bash shtab.main.get_main_parser)\"' \\ | sudo tee \" $BASH_COMPLETION_COMPAT_DIR \" /shtab Note that zsh requires completion script files to be named _{EXECUTABLE} (with an underscore prefix). # note the underscore `_` prefix shtab --shell = zsh shtab.main.get_main_parser --error-unimportable \\ | sudo tee /usr/local/share/zsh/site-functions/_shtab To be more eager, place the generated script somewhere in $fpath . For example, add these lines to the top of ~/.zshrc : mkdir -p ~/.zsh/completions fpath =( $fpath ~/.zsh/completions ) # must be before `compinit` lines shtab --shell = zsh shtab.main.get_main_parser > ~/.zsh/completions/_shtab shtab --shell = tcsh shtab.main.get_main_parser --error-unimportable \\ | sudo tee /etc/profile.d/shtab.completion.csh There are a few options: # Install locally echo 'shtab --shell=tcsh shtab.main.get_main_parser | source /dev/stdin' \\ >> ~/.cshrc # Install system-wide echo 'shtab --shell=tcsh shtab.main.get_main_parser | source /dev/stdin' \\ | sudo tee /etc/profile.d/eager-completion.csh Tip See the examples/ folder for more. Any existing argparse -based scripts should be supported with minimal effort. For example, starting with this existing code: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/usr/bin/env python import argparse def get_main_parser (): parser = argparse . ArgumentParser ( prog = \"MY_PROG\" , ... ) parser . add_argument ( ... ) parser . add_subparsers ( ... ) ... return parser if __name__ == \"__main__\" : parser = get_main_parser () args = parser . parse_args () ... Assuming this code example is installed in MY_PROG.command.main , simply run: bash zsh tcsh shtab --shell = bash -u MY_PROG.command.main.get_main_parser \\ | sudo tee \" $BASH_COMPLETION_COMPAT_DIR \" /MY_PROG shtab --shell = zsh -u MY_PROG.command.main.get_main_parser \\ | sudo tee /usr/local/share/zsh/site-functions/_MY_PROG shtab --shell = tcsh -u MY_PROG.command.main.get_main_parser \\ | sudo tee /etc/profile.d/MY_PROG.completion.csh Library Usage # Tip See the examples/ folder for more. Complex projects with subparsers and custom completions for paths matching certain patterns (e.g. --file=*.txt ) are fully supported (see examples/customcomplete.py or even iterative/dvc:command/completion.py for example). Add direct support to scripts for a little more configurability: argparse docopt pathcomplete.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/usr/bin/env python import argparse import shtab # for completion magic def get_main_parser (): parser = argparse . ArgumentParser ( prog = \"pathcomplete\" ) shtab . add_argument_to ( parser , [ \"-s\" , \"--print-completion\" ]) # magic! # file & directory tab complete parser . add_argument ( \"file\" , nargs = \"?\" ) . complete = shtab . FILE parser . add_argument ( \"--dir\" , default = \".\" ) . complete = shtab . DIRECTORY return parser if __name__ == \"__main__\" : parser = get_main_parser () args = parser . parse_args () print ( \"received <file>= %r --dir= %r \" % ( args . file , args . dir )) Simply use argopt to create a parser object from docopt syntax: docopt-greeter.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/usr/bin/env python \"\"\"Greetings and partings. Usage: greeter [options] [<you>] [<me>] Options: -g, --goodbye : Say \"goodbye\" (instead of \"hello\") Arguments: <you> : Your name [default: Anon] <me> : My name [default: Casper] \"\"\" import argopt , shtab parser = argopt . argopt ( __doc__ ) shtab . add_argument_to ( parser , [ \"-s\" , \"--print-completion\" ]) # magic! if __name__ == \"__main__\" : args = parser . parse_args () msg = \"k thx bai!\" if args . goodbye else \"hai!\" print ( \" {} says ' {} ' to {} \" . format ( args . me , msg , args . you ))","title":"Usage"},{"location":"use/#usage","text":"There are two ways of using shtab : CLI Usage : shtab 's own CLI interface for external applications may not require any code modifications whatsoever end-users execute shtab your_cli_app.your_parser_object Library Usage : as a library integrated into your CLI application adds a couple of lines to your application argument mode: end-users execute your_cli_app --print-completion {bash,zsh,tcsh} subparser mode: end-users execute your_cli_app completion {bash,zsh,tcsh}","title":"Usage"},{"location":"use/#cli-usage","text":"The only requirement is that external CLI applications provide an importable argparse.ArgumentParser object (or alternatively an importable function which returns a parser object). This may require a trivial code change. Once that's done, simply put the output of shtab --shell=your_shell your_cli_app.your_parser_object somewhere your shell looks for completions. Below are various examples of enabling shtab 's own tab completion scripts. Info If both shtab and the module it's completing are globally importable, eager usage is an option. \"Eager\" means automatically updating completions each time a terminal is opened. bash Eager bash zsh Eager zsh tcsh Eager tcsh shtab --shell = bash shtab.main.get_main_parser --error-unimportable \\ | sudo tee \" $BASH_COMPLETION_COMPAT_DIR \" /shtab There are a few options: # Install locally echo 'eval \"$(shtab --shell=bash shtab.main.get_main_parser)\"' \\ >> ~/.bash_completion # Install locally (lazy load for bash-completion>=2.8) echo 'eval \"$(shtab --shell=bash shtab.main.get_main_parser)\"' \\ > \" ${ BASH_COMPLETION_USER_DIR :- ${ XDG_DATA_HOME :- $HOME /.local/share } /bash-completion } /completions/shtab\" # Install system-wide echo 'eval \"$(shtab --shell=bash shtab.main.get_main_parser)\"' \\ | sudo tee \" $( pkg-config --variable = completionsdir bash-completion ) \" /shtab # Install system-wide (legacy) echo 'eval \"$(shtab --shell=bash shtab.main.get_main_parser)\"' \\ | sudo tee \" $BASH_COMPLETION_COMPAT_DIR \" /shtab Note that zsh requires completion script files to be named _{EXECUTABLE} (with an underscore prefix). # note the underscore `_` prefix shtab --shell = zsh shtab.main.get_main_parser --error-unimportable \\ | sudo tee /usr/local/share/zsh/site-functions/_shtab To be more eager, place the generated script somewhere in $fpath . For example, add these lines to the top of ~/.zshrc : mkdir -p ~/.zsh/completions fpath =( $fpath ~/.zsh/completions ) # must be before `compinit` lines shtab --shell = zsh shtab.main.get_main_parser > ~/.zsh/completions/_shtab shtab --shell = tcsh shtab.main.get_main_parser --error-unimportable \\ | sudo tee /etc/profile.d/shtab.completion.csh There are a few options: # Install locally echo 'shtab --shell=tcsh shtab.main.get_main_parser | source /dev/stdin' \\ >> ~/.cshrc # Install system-wide echo 'shtab --shell=tcsh shtab.main.get_main_parser | source /dev/stdin' \\ | sudo tee /etc/profile.d/eager-completion.csh Tip See the examples/ folder for more. Any existing argparse -based scripts should be supported with minimal effort. For example, starting with this existing code: main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/usr/bin/env python import argparse def get_main_parser (): parser = argparse . ArgumentParser ( prog = \"MY_PROG\" , ... ) parser . add_argument ( ... ) parser . add_subparsers ( ... ) ... return parser if __name__ == \"__main__\" : parser = get_main_parser () args = parser . parse_args () ... Assuming this code example is installed in MY_PROG.command.main , simply run: bash zsh tcsh shtab --shell = bash -u MY_PROG.command.main.get_main_parser \\ | sudo tee \" $BASH_COMPLETION_COMPAT_DIR \" /MY_PROG shtab --shell = zsh -u MY_PROG.command.main.get_main_parser \\ | sudo tee /usr/local/share/zsh/site-functions/_MY_PROG shtab --shell = tcsh -u MY_PROG.command.main.get_main_parser \\ | sudo tee /etc/profile.d/MY_PROG.completion.csh","title":"CLI Usage"},{"location":"use/#library-usage","text":"Tip See the examples/ folder for more. Complex projects with subparsers and custom completions for paths matching certain patterns (e.g. --file=*.txt ) are fully supported (see examples/customcomplete.py or even iterative/dvc:command/completion.py for example). Add direct support to scripts for a little more configurability: argparse docopt pathcomplete.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/usr/bin/env python import argparse import shtab # for completion magic def get_main_parser (): parser = argparse . ArgumentParser ( prog = \"pathcomplete\" ) shtab . add_argument_to ( parser , [ \"-s\" , \"--print-completion\" ]) # magic! # file & directory tab complete parser . add_argument ( \"file\" , nargs = \"?\" ) . complete = shtab . FILE parser . add_argument ( \"--dir\" , default = \".\" ) . complete = shtab . DIRECTORY return parser if __name__ == \"__main__\" : parser = get_main_parser () args = parser . parse_args () print ( \"received <file>= %r --dir= %r \" % ( args . file , args . dir )) Simply use argopt to create a parser object from docopt syntax: docopt-greeter.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/usr/bin/env python \"\"\"Greetings and partings. Usage: greeter [options] [<you>] [<me>] Options: -g, --goodbye : Say \"goodbye\" (instead of \"hello\") Arguments: <you> : Your name [default: Anon] <me> : My name [default: Casper] \"\"\" import argopt , shtab parser = argopt . argopt ( __doc__ ) shtab . add_argument_to ( parser , [ \"-s\" , \"--print-completion\" ]) # magic! if __name__ == \"__main__\" : args = parser . parse_args () msg = \"k thx bai!\" if args . goodbye else \"hai!\" print ( \" {} says ' {} ' to {} \" . format ( args . me , msg , args . you ))","title":"Library Usage"}]}